// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               v3.12.4
// source: akasha.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "akasha";

/** The FlagType enum defines the types of flags available. */
export enum FlagType {
  BOOL = 0,
  STRING = 1,
  UNRECOGNIZED = -1,
}

export function flagTypeFromJSON(object: any): FlagType {
  switch (object) {
    case 0:
    case "BOOL":
      return FlagType.BOOL;
    case 1:
    case "STRING":
      return FlagType.STRING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FlagType.UNRECOGNIZED;
  }
}

export function flagTypeToJSON(object: FlagType): string {
  switch (object) {
    case FlagType.BOOL:
      return "BOOL";
    case FlagType.STRING:
      return "STRING";
    case FlagType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The Flag message represents a feature flag. */
export interface Flag {
  id: string;
  name: string;
  type: FlagType;
  boolValue: boolean;
  stringValue: string;
  targetingRules: TargetingRule[];
}

/** The TargetingRule message represents a rule for flag targeting. */
export interface TargetingRule {
  attribute: string;
  /** e.g., "EQUALS", "NOT_EQUALS" */
  operator: string;
  value: string;
}

/** Request and Response messages for FlagService */
export interface CreateFlagRequest {
  flag: Flag | undefined;
}

export interface CreateFlagResponse {
  flag: Flag | undefined;
}

export interface GetFlagRequest {
  id: string;
}

export interface GetFlagResponse {
  flag: Flag | undefined;
}

export interface UpdateFlagRequest {
  flag: Flag | undefined;
}

export interface UpdateFlagResponse {
  flag: Flag | undefined;
}

export interface DeleteFlagRequest {
  id: string;
}

export interface DeleteFlagResponse {
  success: boolean;
}

export interface ListFlagsRequest {
  page: number;
  pageSize: number;
}

export interface ListFlagsResponse {
  flags: Flag[];
  totalCount: number;
}

/** Request and Response messages for MetricsService */
export interface GetMetricsRequest {
  flagId: string;
}

export interface GetMetricsResponse {
  totalQueries: number;
  trueCount: number;
  falseCount: number;
}

function createBaseFlag(): Flag {
  return { id: "", name: "", type: 0, boolValue: false, stringValue: "", targetingRules: [] };
}

export const Flag: MessageFns<Flag> = {
  encode(message: Flag, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.boolValue !== false) {
      writer.uint32(32).bool(message.boolValue);
    }
    if (message.stringValue !== "") {
      writer.uint32(42).string(message.stringValue);
    }
    for (const v of message.targetingRules) {
      TargetingRule.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Flag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFlag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.boolValue = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.stringValue = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.targetingRules.push(TargetingRule.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Flag {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? flagTypeFromJSON(object.type) : 0,
      boolValue: isSet(object.boolValue) ? globalThis.Boolean(object.boolValue) : false,
      stringValue: isSet(object.stringValue) ? globalThis.String(object.stringValue) : "",
      targetingRules: globalThis.Array.isArray(object?.targetingRules)
        ? object.targetingRules.map((e: any) => TargetingRule.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Flag): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== 0) {
      obj.type = flagTypeToJSON(message.type);
    }
    if (message.boolValue !== false) {
      obj.boolValue = message.boolValue;
    }
    if (message.stringValue !== "") {
      obj.stringValue = message.stringValue;
    }
    if (message.targetingRules?.length) {
      obj.targetingRules = message.targetingRules.map((e) => TargetingRule.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Flag>, I>>(base?: I): Flag {
    return Flag.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Flag>, I>>(object: I): Flag {
    const message = createBaseFlag();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.type = object.type ?? 0;
    message.boolValue = object.boolValue ?? false;
    message.stringValue = object.stringValue ?? "";
    message.targetingRules = object.targetingRules?.map((e) => TargetingRule.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTargetingRule(): TargetingRule {
  return { attribute: "", operator: "", value: "" };
}

export const TargetingRule: MessageFns<TargetingRule> = {
  encode(message: TargetingRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.attribute !== "") {
      writer.uint32(10).string(message.attribute);
    }
    if (message.operator !== "") {
      writer.uint32(18).string(message.operator);
    }
    if (message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TargetingRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTargetingRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.attribute = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.operator = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TargetingRule {
    return {
      attribute: isSet(object.attribute) ? globalThis.String(object.attribute) : "",
      operator: isSet(object.operator) ? globalThis.String(object.operator) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: TargetingRule): unknown {
    const obj: any = {};
    if (message.attribute !== "") {
      obj.attribute = message.attribute;
    }
    if (message.operator !== "") {
      obj.operator = message.operator;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TargetingRule>, I>>(base?: I): TargetingRule {
    return TargetingRule.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TargetingRule>, I>>(object: I): TargetingRule {
    const message = createBaseTargetingRule();
    message.attribute = object.attribute ?? "";
    message.operator = object.operator ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCreateFlagRequest(): CreateFlagRequest {
  return { flag: undefined };
}

export const CreateFlagRequest: MessageFns<CreateFlagRequest> = {
  encode(message: CreateFlagRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.flag !== undefined) {
      Flag.encode(message.flag, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateFlagRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateFlagRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.flag = Flag.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateFlagRequest {
    return { flag: isSet(object.flag) ? Flag.fromJSON(object.flag) : undefined };
  },

  toJSON(message: CreateFlagRequest): unknown {
    const obj: any = {};
    if (message.flag !== undefined) {
      obj.flag = Flag.toJSON(message.flag);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateFlagRequest>, I>>(base?: I): CreateFlagRequest {
    return CreateFlagRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateFlagRequest>, I>>(object: I): CreateFlagRequest {
    const message = createBaseCreateFlagRequest();
    message.flag = (object.flag !== undefined && object.flag !== null) ? Flag.fromPartial(object.flag) : undefined;
    return message;
  },
};

function createBaseCreateFlagResponse(): CreateFlagResponse {
  return { flag: undefined };
}

export const CreateFlagResponse: MessageFns<CreateFlagResponse> = {
  encode(message: CreateFlagResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.flag !== undefined) {
      Flag.encode(message.flag, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateFlagResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateFlagResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.flag = Flag.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateFlagResponse {
    return { flag: isSet(object.flag) ? Flag.fromJSON(object.flag) : undefined };
  },

  toJSON(message: CreateFlagResponse): unknown {
    const obj: any = {};
    if (message.flag !== undefined) {
      obj.flag = Flag.toJSON(message.flag);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateFlagResponse>, I>>(base?: I): CreateFlagResponse {
    return CreateFlagResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateFlagResponse>, I>>(object: I): CreateFlagResponse {
    const message = createBaseCreateFlagResponse();
    message.flag = (object.flag !== undefined && object.flag !== null) ? Flag.fromPartial(object.flag) : undefined;
    return message;
  },
};

function createBaseGetFlagRequest(): GetFlagRequest {
  return { id: "" };
}

export const GetFlagRequest: MessageFns<GetFlagRequest> = {
  encode(message: GetFlagRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFlagRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFlagRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFlagRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetFlagRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetFlagRequest>, I>>(base?: I): GetFlagRequest {
    return GetFlagRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetFlagRequest>, I>>(object: I): GetFlagRequest {
    const message = createBaseGetFlagRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseGetFlagResponse(): GetFlagResponse {
  return { flag: undefined };
}

export const GetFlagResponse: MessageFns<GetFlagResponse> = {
  encode(message: GetFlagResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.flag !== undefined) {
      Flag.encode(message.flag, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFlagResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFlagResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.flag = Flag.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFlagResponse {
    return { flag: isSet(object.flag) ? Flag.fromJSON(object.flag) : undefined };
  },

  toJSON(message: GetFlagResponse): unknown {
    const obj: any = {};
    if (message.flag !== undefined) {
      obj.flag = Flag.toJSON(message.flag);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetFlagResponse>, I>>(base?: I): GetFlagResponse {
    return GetFlagResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetFlagResponse>, I>>(object: I): GetFlagResponse {
    const message = createBaseGetFlagResponse();
    message.flag = (object.flag !== undefined && object.flag !== null) ? Flag.fromPartial(object.flag) : undefined;
    return message;
  },
};

function createBaseUpdateFlagRequest(): UpdateFlagRequest {
  return { flag: undefined };
}

export const UpdateFlagRequest: MessageFns<UpdateFlagRequest> = {
  encode(message: UpdateFlagRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.flag !== undefined) {
      Flag.encode(message.flag, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateFlagRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateFlagRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.flag = Flag.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateFlagRequest {
    return { flag: isSet(object.flag) ? Flag.fromJSON(object.flag) : undefined };
  },

  toJSON(message: UpdateFlagRequest): unknown {
    const obj: any = {};
    if (message.flag !== undefined) {
      obj.flag = Flag.toJSON(message.flag);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateFlagRequest>, I>>(base?: I): UpdateFlagRequest {
    return UpdateFlagRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateFlagRequest>, I>>(object: I): UpdateFlagRequest {
    const message = createBaseUpdateFlagRequest();
    message.flag = (object.flag !== undefined && object.flag !== null) ? Flag.fromPartial(object.flag) : undefined;
    return message;
  },
};

function createBaseUpdateFlagResponse(): UpdateFlagResponse {
  return { flag: undefined };
}

export const UpdateFlagResponse: MessageFns<UpdateFlagResponse> = {
  encode(message: UpdateFlagResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.flag !== undefined) {
      Flag.encode(message.flag, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateFlagResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateFlagResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.flag = Flag.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateFlagResponse {
    return { flag: isSet(object.flag) ? Flag.fromJSON(object.flag) : undefined };
  },

  toJSON(message: UpdateFlagResponse): unknown {
    const obj: any = {};
    if (message.flag !== undefined) {
      obj.flag = Flag.toJSON(message.flag);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateFlagResponse>, I>>(base?: I): UpdateFlagResponse {
    return UpdateFlagResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateFlagResponse>, I>>(object: I): UpdateFlagResponse {
    const message = createBaseUpdateFlagResponse();
    message.flag = (object.flag !== undefined && object.flag !== null) ? Flag.fromPartial(object.flag) : undefined;
    return message;
  },
};

function createBaseDeleteFlagRequest(): DeleteFlagRequest {
  return { id: "" };
}

export const DeleteFlagRequest: MessageFns<DeleteFlagRequest> = {
  encode(message: DeleteFlagRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteFlagRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteFlagRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteFlagRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DeleteFlagRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteFlagRequest>, I>>(base?: I): DeleteFlagRequest {
    return DeleteFlagRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteFlagRequest>, I>>(object: I): DeleteFlagRequest {
    const message = createBaseDeleteFlagRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseDeleteFlagResponse(): DeleteFlagResponse {
  return { success: false };
}

export const DeleteFlagResponse: MessageFns<DeleteFlagResponse> = {
  encode(message: DeleteFlagResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteFlagResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteFlagResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteFlagResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: DeleteFlagResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteFlagResponse>, I>>(base?: I): DeleteFlagResponse {
    return DeleteFlagResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteFlagResponse>, I>>(object: I): DeleteFlagResponse {
    const message = createBaseDeleteFlagResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseListFlagsRequest(): ListFlagsRequest {
  return { page: 0, pageSize: 0 };
}

export const ListFlagsRequest: MessageFns<ListFlagsRequest> = {
  encode(message: ListFlagsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFlagsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFlagsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFlagsRequest {
    return {
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
    };
  },

  toJSON(message: ListFlagsRequest): unknown {
    const obj: any = {};
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListFlagsRequest>, I>>(base?: I): ListFlagsRequest {
    return ListFlagsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListFlagsRequest>, I>>(object: I): ListFlagsRequest {
    const message = createBaseListFlagsRequest();
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    return message;
  },
};

function createBaseListFlagsResponse(): ListFlagsResponse {
  return { flags: [], totalCount: 0 };
}

export const ListFlagsResponse: MessageFns<ListFlagsResponse> = {
  encode(message: ListFlagsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.flags) {
      Flag.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalCount !== 0) {
      writer.uint32(16).int32(message.totalCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFlagsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFlagsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.flags.push(Flag.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFlagsResponse {
    return {
      flags: globalThis.Array.isArray(object?.flags) ? object.flags.map((e: any) => Flag.fromJSON(e)) : [],
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
    };
  },

  toJSON(message: ListFlagsResponse): unknown {
    const obj: any = {};
    if (message.flags?.length) {
      obj.flags = message.flags.map((e) => Flag.toJSON(e));
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListFlagsResponse>, I>>(base?: I): ListFlagsResponse {
    return ListFlagsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListFlagsResponse>, I>>(object: I): ListFlagsResponse {
    const message = createBaseListFlagsResponse();
    message.flags = object.flags?.map((e) => Flag.fromPartial(e)) || [];
    message.totalCount = object.totalCount ?? 0;
    return message;
  },
};

function createBaseGetMetricsRequest(): GetMetricsRequest {
  return { flagId: "" };
}

export const GetMetricsRequest: MessageFns<GetMetricsRequest> = {
  encode(message: GetMetricsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.flagId !== "") {
      writer.uint32(10).string(message.flagId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMetricsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMetricsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.flagId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMetricsRequest {
    return { flagId: isSet(object.flagId) ? globalThis.String(object.flagId) : "" };
  },

  toJSON(message: GetMetricsRequest): unknown {
    const obj: any = {};
    if (message.flagId !== "") {
      obj.flagId = message.flagId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMetricsRequest>, I>>(base?: I): GetMetricsRequest {
    return GetMetricsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetMetricsRequest>, I>>(object: I): GetMetricsRequest {
    const message = createBaseGetMetricsRequest();
    message.flagId = object.flagId ?? "";
    return message;
  },
};

function createBaseGetMetricsResponse(): GetMetricsResponse {
  return { totalQueries: 0, trueCount: 0, falseCount: 0 };
}

export const GetMetricsResponse: MessageFns<GetMetricsResponse> = {
  encode(message: GetMetricsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalQueries !== 0) {
      writer.uint32(8).int64(message.totalQueries);
    }
    if (message.trueCount !== 0) {
      writer.uint32(16).int64(message.trueCount);
    }
    if (message.falseCount !== 0) {
      writer.uint32(24).int64(message.falseCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMetricsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMetricsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.totalQueries = longToNumber(reader.int64());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.trueCount = longToNumber(reader.int64());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.falseCount = longToNumber(reader.int64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMetricsResponse {
    return {
      totalQueries: isSet(object.totalQueries) ? globalThis.Number(object.totalQueries) : 0,
      trueCount: isSet(object.trueCount) ? globalThis.Number(object.trueCount) : 0,
      falseCount: isSet(object.falseCount) ? globalThis.Number(object.falseCount) : 0,
    };
  },

  toJSON(message: GetMetricsResponse): unknown {
    const obj: any = {};
    if (message.totalQueries !== 0) {
      obj.totalQueries = Math.round(message.totalQueries);
    }
    if (message.trueCount !== 0) {
      obj.trueCount = Math.round(message.trueCount);
    }
    if (message.falseCount !== 0) {
      obj.falseCount = Math.round(message.falseCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMetricsResponse>, I>>(base?: I): GetMetricsResponse {
    return GetMetricsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetMetricsResponse>, I>>(object: I): GetMetricsResponse {
    const message = createBaseGetMetricsResponse();
    message.totalQueries = object.totalQueries ?? 0;
    message.trueCount = object.trueCount ?? 0;
    message.falseCount = object.falseCount ?? 0;
    return message;
  },
};

/** The FlagService defines CRUD operations for flags. */
export interface FlagService {
  CreateFlag(request: CreateFlagRequest): Promise<CreateFlagResponse>;
  GetFlag(request: GetFlagRequest): Promise<GetFlagResponse>;
  UpdateFlag(request: UpdateFlagRequest): Promise<UpdateFlagResponse>;
  DeleteFlag(request: DeleteFlagRequest): Promise<DeleteFlagResponse>;
  ListFlags(request: ListFlagsRequest): Promise<ListFlagsResponse>;
}

export const FlagServiceServiceName = "akasha.FlagService";
export class FlagServiceClientImpl implements FlagService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || FlagServiceServiceName;
    this.rpc = rpc;
    this.CreateFlag = this.CreateFlag.bind(this);
    this.GetFlag = this.GetFlag.bind(this);
    this.UpdateFlag = this.UpdateFlag.bind(this);
    this.DeleteFlag = this.DeleteFlag.bind(this);
    this.ListFlags = this.ListFlags.bind(this);
  }
  CreateFlag(request: CreateFlagRequest): Promise<CreateFlagResponse> {
    const data = CreateFlagRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateFlag", data);
    return promise.then((data) => CreateFlagResponse.decode(new BinaryReader(data)));
  }

  GetFlag(request: GetFlagRequest): Promise<GetFlagResponse> {
    const data = GetFlagRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetFlag", data);
    return promise.then((data) => GetFlagResponse.decode(new BinaryReader(data)));
  }

  UpdateFlag(request: UpdateFlagRequest): Promise<UpdateFlagResponse> {
    const data = UpdateFlagRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateFlag", data);
    return promise.then((data) => UpdateFlagResponse.decode(new BinaryReader(data)));
  }

  DeleteFlag(request: DeleteFlagRequest): Promise<DeleteFlagResponse> {
    const data = DeleteFlagRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteFlag", data);
    return promise.then((data) => DeleteFlagResponse.decode(new BinaryReader(data)));
  }

  ListFlags(request: ListFlagsRequest): Promise<ListFlagsResponse> {
    const data = ListFlagsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListFlags", data);
    return promise.then((data) => ListFlagsResponse.decode(new BinaryReader(data)));
  }
}

/** The MetricsService provides metrics about flag queries. */
export interface MetricsService {
  GetMetrics(request: GetMetricsRequest): Promise<GetMetricsResponse>;
}

export const MetricsServiceServiceName = "akasha.MetricsService";
export class MetricsServiceClientImpl implements MetricsService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || MetricsServiceServiceName;
    this.rpc = rpc;
    this.GetMetrics = this.GetMetrics.bind(this);
  }
  GetMetrics(request: GetMetricsRequest): Promise<GetMetricsResponse> {
    const data = GetMetricsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetMetrics", data);
    return promise.then((data) => GetMetricsResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
